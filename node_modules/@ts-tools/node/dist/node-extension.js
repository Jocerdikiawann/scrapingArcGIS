"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeVersionToScriptTarget = exports.createTransformerExtension = exports.createNodeExtension = exports.defaultCompilerOptions = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const typescript_1 = __importDefault(require("typescript"));
const source_map_support_1 = __importDefault(require("source-map-support"));
const transpile_1 = require("@ts-tools/transpile");
const { fileExists } = typescript_1.default.sys;
exports.defaultCompilerOptions = {
    // Node 8+.
    target: typescript_1.default.ScriptTarget.ES2017,
    // Node has a CommonJS module system.
    module: typescript_1.default.ModuleKind.CommonJS,
    // Pure commonjs libraries should be importable as default.
    // e.g `import express from 'express';`
    esModuleInterop: true,
    // Transpile jsx to React calls (opinionated).
    jsx: typescript_1.default.JsxEmit.React,
};
/**
 * Creates a cachine TypeScript node extension.
 */
function createNodeExtension({ contextPath = process.cwd(), configLookup = true, configFileName, configFilePath = configLookup ? typescript_1.default.findConfigFile(contextPath, fileExists, configFileName) : undefined, compilerOptions: noConfigOptions = exports.defaultCompilerOptions, cacheDirectoryPath = transpile_1.findCacheDirectory(contextPath), installSourceMapSupport = !process.execArgv.includes('--enable-source-maps'), autoScriptTarget = true, } = {}) {
    const formatDiagnosticsHost = {
        getCurrentDirectory: () => contextPath,
        getCanonicalFileName: transpile_1.getCanonicalPath,
        getNewLine: transpile_1.getNewLine,
    };
    const compilerOptions = {};
    if (typeof configFilePath === 'string') {
        const { options, errors } = transpile_1.readAndParseConfigFile(configFilePath);
        if (errors.length) {
            throw new Error(typescript_1.default.formatDiagnostics(errors, formatDiagnosticsHost));
        }
        Object.assign(compilerOptions, options);
        if (compilerOptions.module !== typescript_1.default.ModuleKind.CommonJS) {
            // force commonjs, for node
            compilerOptions.module = typescript_1.default.ModuleKind.CommonJS;
        }
    }
    else {
        Object.assign(compilerOptions, noConfigOptions);
    }
    // Ensure source maps get picked up by v8 inspector (vscode/chrome debuggers) and node's `--enable-source-maps`.
    compilerOptions.inlineSourceMap = true;
    compilerOptions.sourceMap = compilerOptions.inlineSources = undefined;
    compilerOptions.mapRoot = compilerOptions.sourceRoot = undefined;
    compilerOptions.outDir = compilerOptions.outFile = undefined;
    if (autoScriptTarget) {
        const [nodeMajor] = process.versions.node.split('.'); // '12.0.0' => '12'
        compilerOptions.target = nodeVersionToScriptTarget(Number(nodeMajor));
    }
    if (typeof cacheDirectoryPath !== 'string') {
        // couldn't find a cache directory, so fall back to a non-caching implementation
        return createTransformerExtension((filePath) => typescript_1.default.transpileModule(fs_1.readFileSync(filePath, 'utf8'), { fileName: filePath, compilerOptions }).outputText);
    }
    const optionsScopedCachePath = path_1.join(cacheDirectoryPath, transpile_1.compilerOptionsToCacheName(compilerOptions));
    try {
        transpile_1.ensureDirectorySync(optionsScopedCachePath);
    }
    catch (_a) {
        /**/
    }
    if (installSourceMapSupport) {
        source_map_support_1.default.install({
            environment: 'node',
            retrieveSourceMap(filePath) {
                const cacheFilePath = path_1.join(optionsScopedCachePath, transpile_1.filePathToCacheFileName(filePath));
                const cachedOutput = transpile_1.readCacheFileSync(cacheFilePath);
                if (cachedOutput && cachedOutput.mtime === fs_1.statSync(filePath).mtime.getTime()) {
                    const { sourceMapText, outputText } = cachedOutput;
                    const map = sourceMapText || transpile_1.extractInlineSourceMap(outputText);
                    if (map) {
                        return { map, url: filePath };
                    }
                }
                return null;
            },
        });
    }
    return createTransformerExtension((filePath) => transpile_1.transpileCached({
        cacheDirectoryPath: optionsScopedCachePath,
        fileName: filePath,
        compilerOptions,
    }).outputText);
}
exports.createNodeExtension = createNodeExtension;
function createTransformerExtension(transform) {
    return function nodeExtension(nodeModule, filePath) {
        nodeModule._compile(transform(filePath), filePath);
    };
}
exports.createTransformerExtension = createTransformerExtension;
function nodeVersionToScriptTarget(major) {
    if (major >= 10) {
        // for older TypeScript versions without es2019
        return typescript_1.default.ScriptTarget.ES2019 || typescript_1.default.ScriptTarget.ES2018;
    }
    else {
        return typescript_1.default.ScriptTarget.ES2017;
    }
}
exports.nodeVersionToScriptTarget = nodeVersionToScriptTarget;
//# sourceMappingURL=node-extension.js.map